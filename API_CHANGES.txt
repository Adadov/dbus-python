===============================
API changes in dbus-python-in-c
===============================

:Author: Simon McVittie
:Contact: simon.mcvittie@collabora.co.uk
:Organization: `Collabora Ltd`_
:Date: 2006-09-26

.. _ Collabora Ltd: http://www.collabora.co.uk/

* The Byte constructor accepts either single-byte strings, or integers in
  the range 0 to 255.

* In method parameters, method returns from proxy methods, etc.,
  integers arrive as instances of dbus.Int32 etc., bytes arrive as
  Byte, and so on, rather than everything being converted to an
  appropriate built-in Python type. This means you can tell exactly
  what arguments went over the bus, and their types.

* There is no Variant type any more. Instead, the ``variant_level``
  attribute on D-Bus types gives the number of variant wrappers in
  which it is contained; this is to remove ambiguity. For instance, calling
  this method::

    @dbus.service.method('com.example', in_signature='v', out_signature='') 
    def Print(self, variant):
        print repr(variant)

  yields the following results::

    # on the wire: Variant containing Int32
    Int32(0, variant_level=1)
    # on the wire: Variant containing Variant containing Int32
    Int32(0, variant_level=2)

  Once an object of a D-Bus type has been constructed, its
  ``variant_level`` cannot be altered.

* The D-Bus integer types (dbus.Int32, etc.) are properly range-checked.

* The Array constructor takes arguments (iterable[, signature])
  rather than (iterable[, type][, signature]); ditto for Dict.

* Proxy methods with multiple return values return a tuple rather than
  a list.

* Calling a proxy method with reply ignored, or with async
  handlers, returns None

* ConnectionError no longer exists (it was never raised)

* ``dbus_bindings`` is now called ``_dbus_bindings``, and is considerably
  different internally:

  * connections are private at the libdbus level: shared connections
    are only shared among Python code

  * The MessageIter stuff is now done in C: there's a much simpler
    Python API, ``Message.append(...)`` where positional arguments are
    the things to be appended, and the keyword argument ``signature``
    controls how objects are interpreted

  * The signature-guessing algorithm used if there is no proper
    signature is exposed as a static method,
    ``Message.guess_signature(*args)``

  * Bus is a subclass of Connection rather than being a wrapper object
    which has-a Connection

  * Some relatively internal methods have been renamed starting with
    an underscore - most Python code shouldn't need to use them, and
    they expose the full complexity of Messages etc.

  * The timeouts in _send_with_reply and in _send_with_reply_and_block
    are in (possibly fractional) seconds, as is conventional in Python

  * The specialized Message subclasses have names ending with Message

..
  vim:set sw=2 sts=2 et ft=rst tw=72:
